{"componentChunkName":"component---node-modules-pauliescanlon-gatsby-theme-terminal-src-layouts-source-layout-js","path":"/posts/2020/08/react-hooks-and-matter-js/","result":{"data":{"mdx":{"id":"4aaed4ca-a566-58ce-95fc-fa05a9340175","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"React hooks and matter.js\",\n  \"tags\": [\"React\", \"JavaScript\", \"matter.js\"],\n  \"date\": \"2020-08-03T00:00:00.000Z\",\n  \"author\": \"Paul Scanlon\",\n  \"featuredImageUrl\": \"https://res.cloudinary.com/www-paulie-dev/image/upload/v1596455021/paulie.dev/2020/08/react-hooks-and-matter-js_lj4ozy.jpg\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar Divider = makeShortcode(\"Divider\");\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Recently I was creating a Shopify demo application and became a little underwhelmed with the Checkout experience and so\\ndecided to inject a bit of \\\"joy\\\" into an otherwise quite dull UI component... it was my demo so why not ay? \\uD83E\\uDD37\\u200D\\u2642\\uFE0F\"), mdx(\"p\", null, \"My plan was to add a \\\"particle\\\" every time the quantity of a product in the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Order\"), \" changed. I wanted this particle to\\nhave real world physics and I wanted each particle to have collision detection so that it would bounce off other\\nparticles.\"), mdx(\"p\", null, \"Quite a few years ago I used a physics engined called \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://brm.io/matter-js/\"\n  }), \"matter.js\"), \" but matter.js pre-dates\\nReact so I was curious to see if I could create the same cool physics based \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"animations\"), \" in React.\"), mdx(\"p\", null, \"Here's what I came up with, have a play around with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Qty\"), \" input.\"), mdx(Divider, {\n    mdxType: \"Divider\"\n  }), mdx(Divider, {\n    mdxType: \"Divider\"\n  }), mdx(Checkout, {\n    mdxType: \"Checkout\"\n  }), mdx(Divider, {\n    mdxType: \"Divider\"\n  }), mdx(Divider, {\n    mdxType: \"Divider\"\n  }), mdx(Divider, {\n    mdxType: \"Divider\"\n  }), mdx(\"p\", null, \"If you'd like to start using \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://brm.io/matter-js/\"\n  }), \"matter.js\"), \" in your project I hope this will give you some\\nindication of how to install it, use it, and the bit I really struggled with, how to make the \\\"canvas\\\" and \\\"floor\\\"\\nresponsive.\"), mdx(\"p\", null, \"Start by installing \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://brm.io/matter-js/\"\n  }), \"matter.js\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sh\"\n  }), \"npm install matter-js --save\\n\")), mdx(\"p\", null, \"Next create a component where you'll do all the \\\"matter\\\" setup, and here's an absolute minimal setup that will get you\\nstarted. The src file for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MatterStepOne.js\"), \" can be found\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/PaulieScanlon/paulie-dev-2019/blob/master/src/posts/2020/08/matter-js-demo/MatterStepOne.js\"\n  }), \"here\")), mdx(\"h2\", null, \"Step One - Setup\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"// MatterStepOne.js\\nimport React, { useEffect, useRef } from 'react'\\nimport Matter from 'matter-js'\\n\\nexport const MatterStepOne = () => {\\n  const boxRef = useRef(null)\\n  const canvasRef = useRef(null)\\n\\n  useEffect(() => {\\n    let Engine = Matter.Engine\\n    let Render = Matter.Render\\n    let World = Matter.World\\n    let Bodies = Matter.Bodies\\n\\n    let engine = Engine.create({})\\n\\n    let render = Render.create({\\n      element: boxRef.current,\\n      engine: engine,\\n      canvas: canvasRef.current,\\n      options: {\\n        width: 300,\\n        height: 300,\\n        background: 'rgba(255, 0, 0, 0.5)',\\n        wireframes: false,\\n      },\\n    })\\n\\n    const floor = Bodies.rectangle(150, 300, 300, 20, {\\n      isStatic: true,\\n      render: {\\n        fillStyle: 'blue',\\n      },\\n    })\\n\\n    const ball = Bodies.circle(150, 0, 10, {\\n      restitution: 0.9,\\n      render: {\\n        fillStyle: 'yellow',\\n      },\\n    })\\n\\n    World.add(engine.world, [floor, ball])\\n\\n    Engine.run(engine)\\n    Render.run(render)\\n  }, [])\\n\\n  return (\\n    <div\\n      ref={boxRef}\\n      style={{\\n        width: 300,\\n        height: 300,\\n      }}\\n    >\\n      <canvas ref={canvasRef} />\\n    </div>\\n  )\\n}\\n\")), mdx(\"p\", null, \"Which should render something like this \\uD83D\\uDC47\"), mdx(MatterStepOne, {\n    mdxType: \"MatterStepOne\"\n  }), mdx(Divider, {\n    mdxType: \"Divider\"\n  }), mdx(\"p\", null, \"There's a couple of things going on here so I'll talk you through some React specific methods that we need to use.\"), mdx(\"h3\", null, \"useRef\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useRef\"), \" is used twice here, first to get a ref to the containing div, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"boxRef\"), \" and then again on the canvas,\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"canvasRef\"), \". These are so we can tell matter.js which element to render the canvas in and which canvas we'd like to\\nrender the matter.js \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"engine\"), \" and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"world\"), \" in. You'll see both of those refs used in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Render.create({})\"), \" method.\"), mdx(\"h3\", null, \"useEffect\"), mdx(\"p\", null, \"As you may know using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useEffect\"), \" with an empty dependencies array means the code will only run once and only run when\\nthe component has mounted. It's in here where you can set up the matter.js \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Engine\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Render\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"World\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Bodies\")), mdx(\"h2\", null, \"Step Two - Responsive\"), mdx(\"p\", null, \"I had a long hard look around the internet and couldn't really find anything that helped me out here so I've come up\\nwith my own solution.\"), mdx(\"p\", null, \"The first thing to get your head around is the difference between...\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-html\"\n  }), \"<canvas ref=\\\"{canvasRef}\\\" />\\n\")), mdx(\"p\", null, \"and\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"let render = Render.create({\\n    ...\\n    canvas: canvasRef.current,\\n    options: {\\n    width: 300,\\n    height: 300,\\n    ...\\n    },\\n})\\n\")), mdx(\"p\", null, \"We could use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CSS\"), \" to make the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"canvas\"), \" and containing \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"div\"), \" fill \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"100%\"), \" or to put it another way, make them responsive,\\nbut... matter.js would still think the canvas has a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"width\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"height\"), \" of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"300\")), mdx(\"p\", null, \"To make the canvas truly responsive we need to do update matter.js with some new values which will be used as the\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"width\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"height\"), \". In addition to this the position and width of the floor also need to be updated.\"), mdx(\"p\", null, \"To achieve this I've added a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"resize\"), \" listener to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"window\")), mdx(\"p\", null, \"When the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"window\"), \" is resized \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"handleResize()\"), \" is called which uses \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"getBoundingClientRect()\"), \" to get the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"width\"), \" and\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"height\"), \" of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"boxRef\"), \".\"), mdx(\"p\", null, \"These values are then used to update the state value \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"constraints\"), \" which will cause a re-render then we can grab these\\nnew \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"width\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"height\"), \" values in a second \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useEffect\"), \" which is triggered only when the new constraint values are set\\nand use them to dynamically update both the floor and the canvas\"), mdx(\"p\", null, \"The src file for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MatterStepTwo.js\"), \" can be found\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/PaulieScanlon/paulie-dev-2019/blob/master/src/posts/2020/08/matter-js-demo/MatterStepTwo.js\"\n  }), \"here\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"//MatterStepTwo.js\\nimport React, { useEffect, useState, useRef } from 'react'\\nimport Matter from 'matter-js'\\n\\nconst STATIC_DENSITY = 15\\n\\nexport const MatterStepTwo = () => {\\n  const boxRef = useRef(null)\\n  const canvasRef = useRef(null)\\n\\n  const [constraints, setContraints] = useState()\\n  const [scene, setScene] = useState()\\n\\n  const handleResize = () => {\\n    setContraints(boxRef.current.getBoundingClientRect())\\n  }\\n\\n  useEffect(() => {\\n    let Engine = Matter.Engine\\n    let Render = Matter.Render\\n    let World = Matter.World\\n    let Bodies = Matter.Bodies\\n\\n    let engine = Engine.create({})\\n\\n    let render = Render.create({\\n      element: boxRef.current,\\n      engine: engine,\\n      canvas: canvasRef.current,\\n      options: {\\n        background: 'rgba(255, 0, 0, 0.5)',\\n        wireframes: false,\\n      },\\n    })\\n\\n    const floor = Bodies.rectangle(0, 0, 0, STATIC_DENSITY, {\\n      isStatic: true,\\n      render: {\\n        fillStyle: 'blue',\\n      },\\n    })\\n\\n    const ball = Bodies.circle(150, 0, 10, {\\n      restitution: 0.9,\\n      render: {\\n        fillStyle: 'yellow',\\n      },\\n    })\\n\\n    World.add(engine.world, [floor, ball])\\n\\n    Engine.run(engine)\\n    Render.run(render)\\n\\n    setContraints(boxRef.current.getBoundingClientRect())\\n    setScene(render)\\n\\n    window.addEventListener('resize', handleResize)\\n  }, [])\\n\\n  useEffect(() => {\\n    return () => {\\n      window.removeEventListener('resize', handleResize)\\n    }\\n  }, [])\\n\\n  useEffect(() => {\\n    if (constraints) {\\n      let { width, height } = constraints\\n\\n      // Dynamically update canvas and bounds\\n      scene.bounds.max.x = width\\n      scene.bounds.max.y = height\\n      scene.options.width = width\\n      scene.options.height = height\\n      scene.canvas.width = width\\n      scene.canvas.height = height\\n\\n      // Dynamically update floor\\n      const floor = scene.engine.world.bodies[0]\\n\\n      Matter.Body.setPosition(floor, {\\n        x: width / 2,\\n        y: height + STATIC_DENSITY / 2,\\n      })\\n\\n      Matter.Body.setVertices(floor, [\\n        { x: 0, y: height },\\n        { x: width, y: height },\\n        { x: width, y: height + STATIC_DENSITY },\\n        { x: 0, y: height + STATIC_DENSITY },\\n      ])\\n    }\\n  }, [scene, constraints])\\n\\n  return (\\n    <div style={{ position: 'relative', border: '1px solid blue', padding: '8px' }}>\\n      <div style={{ textAlign: 'center' }}>Checkout</div>\\n      <div\\n        style={{\\n          display: 'grid',\\n          gridTemplateColumns: '1fr auto',\\n          rowGap: '16px',\\n          marginBottom: '32px',\\n        }}\\n      >\\n        <div>SubTitle</div>\\n        <div>\\xA3xxx</div>\\n        <div>Discount</div>\\n        <div>\\xA3xxx</div>\\n        <div>Total</div>\\n        <div>\\xA3xxx</div>\\n      </div>\\n\\n      <button\\n        style={{\\n          cursor: 'pointer',\\n          display: 'block',\\n          textAlign: 'center',\\n          marginBottom: '16px',\\n          width: '100%',\\n        }}\\n      >\\n        Checkout\\n      </button>\\n\\n      <div\\n        ref={boxRef}\\n        style={{\\n          position: 'absolute',\\n          top: 0,\\n          left: 0,\\n          width: '100%',\\n          height: '100%',\\n        }}\\n      >\\n        <canvas ref={canvasRef} />\\n      </div>\\n    </div>\\n  )\\n}\\n\")), mdx(\"p\", null, \"Which should render something like this \\uD83D\\uDC47\"), mdx(MatterStepTwo, {\n    mdxType: \"MatterStepTwo\"\n  }), mdx(Divider, {\n    mdxType: \"Divider\"\n  }), mdx(\"h2\", null, \"Step Three - Triggers\"), mdx(\"p\", null, \"The final step is to trigger a re-render when an interaction happens. In the top example this is when the value of the\\ninputs change but in this step I'll show how to do it from an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"onClick\"), \" on the button. (it's just easier to explain)\"), mdx(\"p\", null, \"The src file for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MatterStepThree.js\"), \" can be found\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/PaulieScanlon/paulie-dev-2019/blob/master/src/posts/2020/08/matter-js-demo/MatterStepThree.js\"\n  }), \"here\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"// MatterStepThree.js\\n\\nimport React, { useEffect, useState, useRef } from 'react'\\nimport Matter from 'matter-js'\\n\\nconst STATIC_DENSITY = 15\\nconst PARTICLE_SIZE = 6\\nconst PARTICLE_BOUNCYNESS = 0.9\\n\\nexport const MatterStepThree = () => {\\n  const boxRef = useRef(null)\\n  const canvasRef = useRef(null)\\n\\n  const [constraints, setContraints] = useState()\\n  const [scene, setScene] = useState()\\n\\n  const [someStateValue, setSomeStateValue] = useState(false)\\n\\n  const handleResize = () => {\\n    setContraints(boxRef.current.getBoundingClientRect())\\n  }\\n\\n  const handleClick = () => {\\n    setSomeStateValue(!someStateValue)\\n  }\\n\\n  useEffect(() => {\\n    let Engine = Matter.Engine\\n    let Render = Matter.Render\\n    let World = Matter.World\\n    let Bodies = Matter.Bodies\\n\\n    let engine = Engine.create({})\\n\\n    let render = Render.create({\\n      element: boxRef.current,\\n      engine: engine,\\n      canvas: canvasRef.current,\\n      options: {\\n        background: 'transparent',\\n        wireframes: false,\\n      },\\n    })\\n\\n    const floor = Bodies.rectangle(0, 0, 0, STATIC_DENSITY, {\\n      isStatic: true,\\n      render: {\\n        fillStyle: 'blue',\\n      },\\n    })\\n\\n    World.add(engine.world, [floor])\\n\\n    Engine.run(engine)\\n    Render.run(render)\\n\\n    setContraints(boxRef.current.getBoundingClientRect())\\n    setScene(render)\\n\\n    window.addEventListener('resize', handleResize)\\n  }, [])\\n\\n  useEffect(() => {\\n    return () => {\\n      window.removeEventListener('resize', handleResize)\\n    }\\n  }, [])\\n\\n  useEffect(() => {\\n    if (constraints) {\\n      let { width, height } = constraints\\n\\n      // Dynamically update canvas and bounds\\n      scene.bounds.max.x = width\\n      scene.bounds.max.y = height\\n      scene.options.width = width\\n      scene.options.height = height\\n      scene.canvas.width = width\\n      scene.canvas.height = height\\n\\n      // Dynamically update floor\\n      const floor = scene.engine.world.bodies[0]\\n\\n      Matter.Body.setPosition(floor, {\\n        x: width / 2,\\n        y: height + STATIC_DENSITY / 2,\\n      })\\n\\n      Matter.Body.setVertices(floor, [\\n        { x: 0, y: height },\\n        { x: width, y: height },\\n        { x: width, y: height + STATIC_DENSITY },\\n        { x: 0, y: height + STATIC_DENSITY },\\n      ])\\n    }\\n  }, [scene, constraints])\\n\\n  useEffect(() => {\\n    // Add a new \\\"ball\\\" everytime `someStateValue` changes\\n    if (scene) {\\n      let { width } = constraints\\n      let randomX = Math.floor(Math.random() * -width) + width\\n      Matter.World.add(\\n        scene.engine.world,\\n        Matter.Bodies.circle(randomX, -PARTICLE_SIZE, PARTICLE_SIZE, {\\n          restitution: PARTICLE_BOUNCYNESS,\\n        }),\\n      )\\n    }\\n  }, [someStateValue])\\n\\n  return (\\n    <div\\n      style={{\\n        position: 'relative',\\n        border: '1px solid white',\\n        padding: '8px',\\n      }}\\n    >\\n      <div style={{ textAlign: 'center' }}>Checkout</div>\\n      <div\\n        style={{\\n          display: 'grid',\\n          gridTemplateColumns: '1fr auto',\\n          rowGap: '16px',\\n          marginBottom: '32px',\\n        }}\\n      >\\n        <div>SubTitle</div>\\n        <div>\\xA3xxx</div>\\n        <div>Discount</div>\\n        <div>\\xA3xxx</div>\\n        <div>Total</div>\\n        <div>\\xA3xxx</div>\\n      </div>\\n\\n      <button\\n        style={{\\n          cursor: 'pointer',\\n          display: 'block',\\n          textAlign: 'center',\\n          marginBottom: '16px',\\n          width: '100%',\\n        }}\\n        onClick={() => handleClick()}\\n      >\\n        Checkout\\n      </button>\\n\\n      <div\\n        ref={boxRef}\\n        style={{\\n          position: 'absolute',\\n          top: 0,\\n          left: 0,\\n          width: '100%',\\n          height: '100%',\\n          pointerEvents: 'none',\\n        }}\\n      >\\n        <canvas ref={canvasRef} />\\n      </div>\\n    </div>\\n  )\\n}\\n\")), mdx(\"p\", null, \"Which should render something like this \\uD83D\\uDC47, go ahead and click the \\\"Checkout\\\" button\"), mdx(MatterStepThree, {\n    mdxType: \"MatterStepThree\"\n  }), mdx(\"p\", null, \"The main takeout from this is that to add a new ball I've added another \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useEffect\"), \" that is triggered when\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"someStateValue\"), \" changes. The code in this \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useEffect\"), \" adds a new ball at a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"randomX\"), \" position between 0 and what ever\\nthe current \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"width\"), \" is set to. In this example it's the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"onClick\"), \" that changes the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"someStateValue\"), \" but in the top\\nexample that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useEffect\"), \" is triggered whenever the quantities change and is fired by the inputs not the Checkout\\nbutton... apologies if that's a little confusing!\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"Recently I was creating a Shopify demo application and became a little underwhelmed with the Checkout experience and so\ndecided to inject a…","timeToRead":3,"wordCount":{"words":675},"slug":"2020/08/react-hooks-and-matter-js","frontmatter":{"title":"React hooks and matter.js","tags":["React","JavaScript","matter.js"],"date":"2020-08-03T00:00:00.000Z","dateModified":null,"author":"Paul Scanlon","status":null,"isPrivate":null,"url":null,"misc":null,"pinned":null,"featuredImage":null,"embeddedImages":null},"featuredImageUrl":{"url":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/2wBDAQoLCw4NDhwQEBw7KCIoOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozv/wgARCAALABQDASIAAhEBAxEB/8QAGQAAAgMBAAAAAAAAAAAAAAAAAAIBAwQG/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAH/2gAMAwEAAhADEAAAAeqivbCjlf/EABgQAQEBAQEAAAAAAAAAAAAAAAIBExAR/9oACAEBAAEFAklFo/DbSWtOf//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABURAQEAAAAAAAAAAAAAAAAAAAEQ/9oACAECAQE/ASf/xAAcEAEAAgEFAAAAAAAAAAAAAAABABEhECMyUXH/2gAIAQEABj8C4L5HaYKU9QLxnX//xAAaEAACAwEBAAAAAAAAAAAAAAABIQARQRDB/9oACAEBAAE/IbeBah08BCw5cxgyybGeu//aAAwDAQACAAMAAAAQVB//xAAXEQEBAQEAAAAAAAAAAAAAAAABABEh/9oACAEDAQE/EER7Lrf/xAAWEQADAAAAAAAAAAAAAAAAAAABEBH/2gAIAQIBAT8QKr//xAAcEAEBAAMAAwEAAAAAAAAAAAABEQAhMRBBUcH/2gAIAQEAAT8QBN6LFN+67/MT7/dTeGKntIqvlxDWrY75Bvz/AP/Z"},"images":{"fallback":{"src":"/static/32cc4f273697cb8d724f9ef333a626a9/ccd19/react-hooks-and-matter-js_lj4ozy.jpg","srcSet":"/static/32cc4f273697cb8d724f9ef333a626a9/5de87/react-hooks-and-matter-js_lj4ozy.jpg 750w,\n/static/32cc4f273697cb8d724f9ef333a626a9/ccd19/react-hooks-and-matter-js_lj4ozy.jpg 1024w","sizes":"100vw"},"sources":[{"srcSet":"/static/32cc4f273697cb8d724f9ef333a626a9/5846e/react-hooks-and-matter-js_lj4ozy.avif 750w,\n/static/32cc4f273697cb8d724f9ef333a626a9/47b7d/react-hooks-and-matter-js_lj4ozy.avif 1024w","type":"image/avif","sizes":"100vw"},{"srcSet":"/static/32cc4f273697cb8d724f9ef333a626a9/d02c5/react-hooks-and-matter-js_lj4ozy.webp 750w,\n/static/32cc4f273697cb8d724f9ef333a626a9/d819f/react-hooks-and-matter-js_lj4ozy.webp 1024w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5625}}}},"embeddedImageUrls":null,"fields":{"slug":"/posts/2020/08/react-hooks-and-matter-js/","owner":"source","parent":"posts"}}},"pageContext":{"id":"4aaed4ca-a566-58ce-95fc-fa05a9340175","prev":{"frontmatter":{"title":"Best Bits 2020 ...","status":null},"fields":{"slug":"/posts/2020/best-bits-2020/"}},"next":{"frontmatter":{"title":"Add Playful Animated SVG Reactions to a Gatsby Blog","status":null},"fields":{"slug":"/writing/2020/07/playful-animated-reactions/"}},"parent":"posts"}},"staticQueryHashes":["1095393795","1469902088","2504239491","3642847879","571831435"]}
{"componentChunkName":"component---node-modules-pauliescanlon-gatsby-theme-terminal-src-layouts-source-layout-js","path":"/posts/2021/01/react-svg-doughnut-chart/","result":{"data":{"mdx":{"id":"25e64de7-709f-51d2-82ae-2d5d3bb66458","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Create an Svg Doughnut Chart from scratch for your Gatsby blog\",\n  \"tags\": [\"JavaScript\", \"React\", \"SVG\", \"Gatsby\", \"CSS\"],\n  \"date\": \"2021-01-11T00:00:00.000Z\",\n  \"author\": \"Paul Scanlon\",\n  \"featuredImageUrl\": \"https://res.cloudinary.com/www-paulie-dev/image/upload/v1610380360/paulie.dev/2021/01/react-svg-doughnut-chart_u7wza7.jpg\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar Divider = makeShortcode(\"Divider\");\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Charting libraries are great don't get me wrong but sometimes... you just need a bloody doughnut! \\uD83C\\uDF69\"), mdx(\"p\", null, \"This post is largely based on this\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://medium.com/@heyoka/scratch-made-svg-donut-pie-charts-in-html5-2c587e935d72\"\n  }), \"article\"), \" by\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://twitter.com/heyoka\"\n  }), \"Mark Caron\"), \" and using this as the foundation i'm going to explain how I created the \\\"tags\\\"\\nchart seen in my \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/dashboard\"\n  }), \"dashboard\")), mdx(\"p\", null, \"To start with I created a new React component and called it \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MrDoughnut\"), \" and by using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useStaticQuery\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"graphql\"), \"\\nfrom \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gatsby\"), \" I'm able to query the tags used in my blog posts\"), mdx(Divider, {\n    mdxType: \"Divider\"\n  }), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"// MrDoughnut.js\\n\\nimport React from \\\"react\\\"\\nimport { useStaticQuery, graphql } from \\\"gatsby\\\"\\n\\nexport const MrDoughnut = () => {\\n  const tagData = useStaticQuery(graphql`\\n    query TagsQuery {\\n      allMdx(filter: { frontmatter: { tags: { ne: null } } }) {\\n        edges {\\n          node {\\n            frontmatter {\\n              tags\\n            }\\n          }\\n        }\\n      }\\n    }\\n  `)\\n\\n  console.log(JSON.stringify(tagData.allMdx.edges, null, 2))\\n\\n  return <div>MrDoughnut</div>\\n\\n\")), mdx(Divider, {\n    mdxType: \"Divider\"\n  }), mdx(\"p\", null, \"Which outputs something similar to the below \\uD83D\\uDC47\"), mdx(Divider, {\n    mdxType: \"Divider\"\n  }), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \";[\\n  {\\n    node: {\\n      frontmatter: {\\n        tags: ['JavaScript', 'React', 'Gatsby', 'SVG', 'Netlify Functions', 'GitHub REST'],\\n      },\\n    },\\n  },\\n  {\\n    node: {\\n      frontmatter: {\\n        tags: ['React'],\\n      },\\n    },\\n  },\\n  {\\n    node: {\\n      frontmatter: {\\n        tags: ['JavaScript', 'React', 'SVG'],\\n      },\\n    },\\n  },\\n]\\n\")), mdx(Divider, {\n    mdxType: \"Divider\"\n  }), mdx(\"p\", null, \"This is a good start but to use this data to drive \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<MrDoughnut />\"), \" it needs to be \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"massaged\"), \" into a slightly different\\nshape.\"), mdx(\"p\", null, \"Ideally what I need is an object for each tag name containing a value for the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"tag\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"count\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"percentage\"), \" and\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"remainder\"), \".\"), mdx(\"p\", null, \"A shape like this will do the trick \\uD83D\\uDC47\"), mdx(Divider, {\n    mdxType: \"Divider\"\n  }), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \";[\\n  {\\n    tag: 'React',\\n    count: 3,\\n    percentage: x,\\n    remainder: x,\\n  },\\n]\\n\")), mdx(Divider, {\n    mdxType: \"Divider\"\n  }), mdx(\"p\", null, \"To modify the shape of any data the most common method to use is\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce\"\n  }), \"Array.prototype.reduce\")), mdx(\"h2\", null, mdx(\"a\", _extends({\n    parentName: \"h2\"\n  }, {\n    \"href\": \"#the-data\"\n  }), \"The Data\")), mdx(\"h3\", null, mdx(\"a\", _extends({\n    parentName: \"h3\"\n  }, {\n    \"href\": \"#step-one\"\n  }), \"Step one\")), mdx(\"p\", null, \"Reduce all the tag names into one array\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\"\n  }), \"// MrDoughnut.js\\n\\nimport React from \\\"react\\\"\\nimport { useStaticQuery, graphql } from \\\"gatsby\\\"\\n\\nexport const MrDoughnut = () => {\\n  const tagData = useStaticQuery(graphql`\\n    query TagsQuery {\\n      allMdx(filter: { frontmatter: { tags: { ne: null } } }) {\\n        edges {\\n          node {\\n            frontmatter {\\n              tags\\n            }\\n          }\\n        }\\n      }\\n    }\\n-  `)\\n+  `) .allMdx.edges.reduce((items, item) => {\\n    const { tags } = item.node.frontmatter\\n    tags.map((tag) => items.push(tag))\\n    return items\\n  }, [])\\n\\n-  console.log(JSON.stringify(tagData.allMdx.edges, null, 2))\\n+  console.log(JSON.stringify(tagData, null, 2))\\n\\n  return <div>MrDoughnut</div>\\n\")), mdx(Divider, {\n    mdxType: \"Divider\"\n  }), mdx(\"p\", null, \"Which results in an array of strings similar to the below \\uD83D\\uDC47\"), mdx(Divider, {\n    mdxType: \"Divider\"\n  }), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"[\\n  \\\"Dummy\\\",\\n  \\\"Tags\\\",\\n  \\\"JavaScript\\\",\\n  \\\"React\\\",\\n  \\\"Gatsby\\\",\\n  \\\"SVG\\\",\\n  \\\"Netlify Functions\\\",\\n  \\\"GitHub REST\\\",\\n  \\\"React\\\",\\n  \\\"React\\\",\\n  \\\"Gatsby\\\",\\n  \\\"Gatsby Cloud\\\",\\n  ...\\n\")), mdx(Divider, {\n    mdxType: \"Divider\"\n  }), mdx(\"p\", null, \"You'll notice there are duplicates in this array and in step two i'll count the duplicates which will give me enough\\ndata to work out what percentage each tag represents.\"), mdx(\"h3\", null, mdx(\"a\", _extends({\n    parentName: \"h3\"\n  }, {\n    \"href\": \"#step-two\"\n  }), \"Step two\")), mdx(\"p\", null, \"Count the amount of duplicate items and assign a value in a new object key called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"count\"), \" and return this value along\\nwith the tag name\"), mdx(Divider, {\n    mdxType: \"Divider\"\n  }), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\"\n  }), \"// MrDoughnut.js\\n\\n\\nimport React from \\\"react\\\"\\nimport { useStaticQuery, graphql } from \\\"gatsby\\\"\\n\\nexport const MrDoughnut = () => {\\n  const tagData = useStaticQuery(graphql`\\n    query TagsQuery {\\n      allMdx(filter: { frontmatter: { tags: { ne: null } } }) {\\n        edges {\\n          node {\\n            frontmatter {\\n              tags\\n            }\\n          }\\n        }\\n      }\\n    }\\n  `)\\n    .allMdx.edges.reduce((items, item) => {\\n      const { tags } = item.node.frontmatter\\n      tags.map((tag) => items.push(tag))\\n      return items\\n    }, [])\\n+    .reduce((items, item) => {\\n+      const existingItem = items.find((index) => index.tag === item)\\n+\\n+      if (existingItem) {\\n+        existingItem.count += 1\\n+      } else {\\n+        items.push({\\n+          tag: item,\\n+          count: 1,\\n+        })\\n+      }\\n\\n+      return items\\n+    }, [])\\n\\n  console.log(JSON.stringify(tagData, null, 2))\\n\\n  return <div>MrDoughnut</div>\\n}\\n\")), mdx(Divider, {\n    mdxType: \"Divider\"\n  }), mdx(\"p\", null, \"In the above snippet I use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"array.reduce()\"), \" in order to determine if it's an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"existingItem\"), \" where i'll increment the\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"count\"), \" or return a new item with a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"count\"), \" of 1 . Using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"array.find()\"), \" I loop over the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"items\"), \" to see if the array\\ncontains the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"item\"), \" passed from the params in the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"parent\"), \" \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"array.reduce()\"), \" \\uD83D\\uDE13\"), mdx(\"p\", null, \"This gives me an output similar to the below \\uD83D\\uDC47\"), mdx(Divider, {\n    mdxType: \"Divider\"\n  }), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"  {\\n    \\\"tag\\\": \\\"JavaScript\\\",\\n    \\\"count\\\": 18\\n  },\\n  {\\n    \\\"tag\\\": \\\"React\\\",\\n    \\\"count\\\": 19\\n  },\\n  {\\n    \\\"tag\\\": \\\"Gatsby\\\",\\n    \\\"count\\\": 32\\n  },\\n  {\\n    \\\"tag\\\": \\\"SVG\\\",\\n    \\\"count\\\": 5\\n  },\\n  {\\n    \\\"tag\\\": \\\"Netlify Functions\\\",\\n    \\\"count\\\": 2\\n  },\\n\")), mdx(Divider, {\n    mdxType: \"Divider\"\n  }), mdx(\"h3\", null, mdx(\"a\", _extends({\n    parentName: \"h3\"\n  }, {\n    \"href\": \"#step-three\"\n  }), \"Step three\")), mdx(\"p\", null, \"Using the new \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"count\"), \" value I need to calculate how this corresponds to the total count from the array which I'll use to\\ncreate the percentage value for each tag\"), mdx(Divider, {\n    mdxType: \"Divider\"\n  }), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\"\n  }), \"// MrDoughnut.js\\n\\nimport React from \\\"react\\\"\\nimport { useStaticQuery, graphql } from \\\"gatsby\\\"\\n\\nexport const MrDoughnut = () => {\\n  const tagData = useStaticQuery(graphql`\\n    query TagsQuery {\\n      allMdx(filter: { frontmatter: { tags: { ne: null } } }) {\\n        edges {\\n          node {\\n            frontmatter {\\n              tags\\n            }\\n          }\\n        }\\n      }\\n    }\\n  `)\\n    .allMdx.edges.reduce((items, item) => {\\n      const { tags } = item.node.frontmatter\\n      tags.map((tag) => items.push(tag))\\n      return items\\n    }, [])\\n    .reduce((items, item) => {\\n      const existingItem = items.find((index) => index.tag === item)\\n\\n      if (existingItem) {\\n        existingItem.count += 1\\n      } else {\\n        items.push({\\n          tag: item,\\n          count: 1,\\n        })\\n      }\\n\\n      return items\\n    }, [])\\n+    .map((item, index, array) => {\\n+      const { count } = item\\n+      const countTotal = array.reduce((a, b) => a + b.count, 0)\\n+      const percentage = (count / countTotal) * 100\\n+      const remainder = 100 - percentage\\n+      return {\\n+        ...item,\\n+        percentage: percentage,\\n+        remainder: remainder,\\n+      }\\n+    })\\n\\n  console.log(JSON.stringify(tagData, null, 2))\\n\\n  return <div>MrDoughnut</div>\\n}\\n\\n\")), mdx(Divider, {\n    mdxType: \"Divider\"\n  }), mdx(\"p\", null, \"In this step I use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"array.map()\"), \" to loop over the newly constructed \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"name: '', count: ''\"), \" object and using\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"array.reduce()\"), \" I sum up \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"all\"), \" the count values for each tag name to create a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"countTotal\"), \". A percentage can then be\\ncalculated by dividing the current \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"count\"), \" value by the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"countTotal\"), \" value and multiplying it by 100. The remainder is\\ncalculated in a similar way by subtracting it from 100. I'll need the remainder later when I come to draw the\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<circle />\"), \" element used in the chart.\"), mdx(\"p\", null, \"The final return statement spreads the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"item\"), \" object along with the new \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"percentage\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"remainder\"), \" values.\"), mdx(\"h3\", null, mdx(\"a\", _extends({\n    parentName: \"h3\"\n  }, {\n    \"href\": \"#step-four\"\n  }), \"Step four\")), mdx(\"p\", null, \"Return the values with the largest count first\"), mdx(Divider, {\n    mdxType: \"Divider\"\n  }), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\"\n  }), \"// MrDoughnut.js\\n\\nimport React from \\\"react\\\"\\nimport { useStaticQuery, graphql } from \\\"gatsby\\\"\\n\\nexport const MrDoughnut = () => {\\n  const tagData = useStaticQuery(graphql`\\n    query TagsQuery {\\n      allMdx(filter: { frontmatter: { tags: { ne: null } } }) {\\n        edges {\\n          node {\\n            frontmatter {\\n              tags\\n            }\\n          }\\n        }\\n      }\\n    }\\n  `)\\n    .allMdx.edges.reduce((items, item) => {\\n      const { tags } = item.node.frontmatter\\n      tags.map((tag) => items.push(tag))\\n      return items\\n    }, [])\\n    .reduce((items, item) => {\\n      const existingItem = items.find((index) => index.tag === item)\\n\\n      if (existingItem) {\\n        existingItem.count += 1\\n      } else {\\n        items.push({\\n          tag: item,\\n          count: 1,\\n        })\\n      }\\n\\n      return items\\n    }, [])\\n+    .sort((a, b) => b.count - a.count)\\n+    .slice(0, 5)\\n    .map((item, index, array) => {\\n      const { count } = item\\n      const countTotal = array.reduce((a, b) => a + b.count, 0)\\n      const percentage = (count / countTotal) * 100\\n      const remainder = 100 - percentage\\n      return {\\n        ...item,\\n        percentage: percentage,\\n        remainder: remainder,\\n      }\\n    })\\n\\n  console.log(JSON.stringify(tagData, null, 2))\\n\\n  return <div>MrDoughnut</div>\\n}\\n\\n\")), mdx(Divider, {\n    mdxType: \"Divider\"\n  }), mdx(\"p\", null, \"Using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"array.sort()\"), \" I return the array ordered by the largest count in ascending order. \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"I've added an\\n\", mdx(\"inlineCode\", {\n    parentName: \"em\"\n  }, \"array.slice(0,5)\"), \" because I'm only concerned with the top five results\")), mdx(\"p\", null, \"Now that I have the data in the correct shape it's time to tackle the Doughnut Chart itself.\"), mdx(\"p\", null, \"The general idea is to use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"array.map()\"), \" again but this time in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Jsx\"), \" to loop over each of the tag objects and return a\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<circle />\"), \" for each one.\"), mdx(\"p\", null, \"By using a combination of CSS values; \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"strokeDashoffset\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"strokeDasharray\"), \" I'm able to determine where to start and\\nend the stroke\"), mdx(\"h2\", null, mdx(\"a\", _extends({\n    parentName: \"h2\"\n  }, {\n    \"href\": \"#the-chart\"\n  }), \"The Chart\")), mdx(\"p\", null, \"Return a circle for each \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"tag\"), \" item and set a stroke color\"), mdx(Divider, {\n    mdxType: \"Divider\"\n  }), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\"\n  }), \"// MrDoughnut.js\\n\\nimport React from \\\"react\\\"\\nimport { useStaticQuery, graphql } from \\\"gatsby\\\"\\n\\nexport const MrDoughnut = () => {\\n  const tagData = useStaticQuery(graphql`\\n    query TagsQuery {\\n      allMdx(filter: { frontmatter: { tags: { ne: null } } }) {\\n        edges {\\n          node {\\n            frontmatter {\\n              tags\\n            }\\n          }\\n        }\\n      }\\n    }\\n  `)\\n    .allMdx.edges.reduce((items, item) => {\\n      const { tags } = item.node.frontmatter\\n      tags.map((tag) => items.push(tag))\\n      return items\\n    }, [])\\n    .reduce((items, item) => {\\n      const existingItem = items.find((index) => index.tag === item)\\n\\n      if (existingItem) {\\n        existingItem.count += 1\\n      } else {\\n        items.push({\\n          tag: item,\\n          count: 1,\\n        })\\n      }\\n\\n      return items\\n    }, [])\\n    .sort((a, b) => b.count - a.count)\\n    .slice(0, 5)\\n    .map((item, index, array) => {\\n      const { count } = item\\n      const countTotal = array.reduce((a, b) => a + b.count, 0)\\n      const percentage = (count / countTotal) * 100\\n      const remainder = 100 - percentage\\n      return {\\n        ...item,\\n        percentage: percentage,\\n        remainder: remainder,\\n      }\\n    })\\n\\n  console.log(JSON.stringify(tagData, null, 2))\\n\\n+ const colors = [\\\"#ff6090\\\", \\\"#3f51b5\\\", \\\"#00bcd4\\\", \\\"#8bc34a\\\", \\\"#ffc107\\\"]\\n\\n-  return <div>MrDoughnut</div>\\n\\n+  return (\\n+    <div\\n+      style={{\\n+        width: 300,\\n+      }}\\n+    >\\n+      <svg width=\\\"100%\\\" height=\\\"100%\\\" viewBox=\\\"0 0 40 40\\\">\\n+        {tagData.map((tag, index) => {\\n+          return (\\n+            <circle\\n+              key={index}\\n+              cx=\\\"20\\\"\\n+              cy=\\\"20\\\"\\n+              r=\\\"15.91549430918954\\\"\\n+              strokeWidth=\\\"6\\\"\\n+              fill=\\\"transparent\\\"\\n+              stroke={colors[index]}\\n+            />\\n+          )\\n+        })}\\n+      </svg>\\n+    </div>\\n+  )\\n}\\n\\n\")), mdx(Divider, {\n    mdxType: \"Divider\"\n  }), mdx(\"p\", null, \"In this step I return an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"svg\"), \" with a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"viewBox\"), \" property of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"0,0,40,40\"), \", to be honest this value doesn't really matter\\nbecause the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"s\"), \" in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"svg\"), \" stands for \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"scalable\"), \" however, it is important that the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"cx\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"cy\"), \" values for each\\ncircle are half the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"viewBox\"), \" value, e.g 20\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"svg\"), \" has a width and height of 100% which means it will fill 100% of whatever it's contained within. In this case I\\nhave a parent \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"div\"), \" with a width of 300\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"r\"), \" value is where things get a bit \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"mathematical\"), \". \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"r\"), \" is the\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/r\"\n  }), \"radius\"), \" of the circle.\"), mdx(\"p\", null, \"As \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://twitter.com/heyoka\"\n  }), \"Mark Caron\"), \" mentions in\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://medium.com/@heyoka/scratch-made-svg-donut-pie-charts-in-html5-2c587e935d72\"\n  }), \"this article\"), \" keeping things human\\nreadable helps with the complexity and basing everything off 100 goes someway to achieving this.\"), mdx(\"p\", null, \"The calculation to create the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"r\"), \" value looks like this \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"100/(2\\u03C0)\"), \" which roughly translates to 100 divided by 2,\\nmultiplied by pi, where pi is approximately 3.14... or in actual numbers 100 / 6.28\"), mdx(\"p\", null, \"For the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"stroke\"), \" color i've defined an array of colours that's the same length as the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"tagData\")), mdx(\"p\", null, \"The next step is a bit tricky and to prevent the strokes from overlapping I'm using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"strokeDashoffset\"), \" and\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"strokeDasharray\"), \" to determine how much of the circumference of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<circle />\"), \" the stroke should cover and where the\\nstroke should start\"), mdx(Divider, {\n    mdxType: \"Divider\"\n  }), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\"\n  }), \"// MrDoughnut.js\\n\\nimport React from \\\"react\\\"\\nimport { useStaticQuery, graphql } from \\\"gatsby\\\"\\n\\nexport const MrDoughnut = () => {\\n  const tagData = useStaticQuery(graphql`\\n    query TagsQuery {\\n      allMdx(filter: { frontmatter: { tags: { ne: null } } }) {\\n        edges {\\n          node {\\n            frontmatter {\\n              tags\\n            }\\n          }\\n        }\\n      }\\n    }\\n  `)\\n    .allMdx.edges.reduce((items, item) => {\\n      const { tags } = item.node.frontmatter\\n      tags.map((tag) => items.push(tag))\\n      return items\\n    }, [])\\n    .reduce((items, item) => {\\n      const existingItem = items.find((index) => index.tag === item)\\n\\n      if (existingItem) {\\n        existingItem.count += 1\\n      } else {\\n        items.push({\\n          tag: item,\\n          count: 1,\\n        })\\n      }\\n\\n      return items\\n    }, [])\\n    .sort((a, b) => b.count - a.count)\\n    .slice(0, 5)\\n    .map((item, index, array) => {\\n      const { count } = item\\n      const countTotal = array.reduce((a, b) => a + b.count, 0)\\n      const percentage = (count / countTotal) * 100\\n      const remainder = 100 - percentage\\n      return {\\n        ...item,\\n        percentage: percentage,\\n        remainder: remainder,\\n      }\\n    })\\n\\n  console.log(JSON.stringify(tagData, null, 2))\\n\\n  const colors = [\\\"#ff6090\\\", \\\"#3f51b5\\\", \\\"#00bcd4\\\", \\\"#8bc34a\\\", \\\"#ffc107\\\"]\\n\\n  return (\\n    <div\\n      style={{\\n        width: 300,\\n      }}\\n    >\\n      <svg width=\\\"100%\\\" height=\\\"100%\\\" viewBox=\\\"0 0 40 40\\\">\\n        {tagData.map((tag, index) => {\\n          const { percentage, remainder } = tag\\n\\n          return (\\n            <circle\\n              key={index}\\n              cx=\\\"20\\\"\\n              cy=\\\"20\\\"\\n              r=\\\"15.91549430918954\\\"\\n+             strokeDasharray={`${percentage} ${remainder}`}\\n+             strokeDashoffset={100 - tagData.slice(0, index).reduce((a, b) => a + b.percentage, 0) + 25}\\n              strokeWidth=\\\"6\\\"\\n              fill=\\\"transparent\\\"\\n              stroke={colors[index]}\\n            />\\n          )\\n        })}\\n      </svg>\\n    </div>\\n  )\\n}\\n\")), mdx(Divider, {\n    mdxType: \"Divider\"\n  }), mdx(\"p\", null, \"Here I'm using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"percentage\"), \" and the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"remainder\"), \" to determine how much of the circle the stroke should cover and to\\ndetermine where the stroke starts. To calculate these values here's the formula \\uD83D\\uDC47\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"(circumference) - (all preceding segments percentage) + (starting position)\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The circumference = 100\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"All preceding segments percentage = a sum of a slice of the total \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"tagData\"), \" percentage\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The start position = 25 and is to offset the start point for each stroke so it's at the top of the circle\")), mdx(\"h2\", null, mdx(\"a\", _extends({\n    parentName: \"h2\"\n  }, {\n    \"href\": \"#the-legend\"\n  }), \"The legend\")), mdx(\"p\", null, \"A lot of charting libraries will plot a title next to each segments to help users identify what each segment represents\\nalong with a value. However, and i've wrestled with this so many times because I like to develop \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"mobile first\"), \" and more\\noften than not this approach results in text too small to read on smaller screens.\"), mdx(\"p\", null, \"Instead, I generally opt for positioning a color coded legend below the chart to ensure the text always remains legible.\"), mdx(\"p\", null, \"The complete component now looks like the below \\uD83D\\uDC47 and the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"src\"), \" can be found\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/PaulieScanlon/paulie-dev-2019/tree/master/src/posts/2021/01/MrDoughnut.js\"\n  }), \"here\")), mdx(Divider, {\n    mdxType: \"Divider\"\n  }), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\"\n  }), \"// MrDoughnut.js\\n\\nimport React from \\\"react\\\"\\nimport { useStaticQuery, graphql } from \\\"gatsby\\\"\\n\\nexport const MrDoughnut = () => {\\n  const tagData = useStaticQuery(graphql`\\n    query TagsQuery {\\n      allMdx(filter: { frontmatter: { tags: { ne: null } } }) {\\n        edges {\\n          node {\\n            frontmatter {\\n              tags\\n            }\\n          }\\n        }\\n      }\\n    }\\n  `)\\n    .allMdx.edges.reduce((items, item) => {\\n      const { tags } = item.node.frontmatter\\n      tags.map((tag) => items.push(tag))\\n      return items\\n    }, [])\\n    .reduce((items, item) => {\\n      const existingItem = items.find((index) => index.tag === item)\\n\\n      if (existingItem) {\\n        existingItem.count += 1\\n      } else {\\n        items.push({\\n          tag: item,\\n          count: 1,\\n        })\\n      }\\n\\n      return items\\n    }, [])\\n    .sort((a, b) => b.count - a.count)\\n    .slice(0, 5)\\n    .map((item, index, array) => {\\n      const { count } = item\\n      const countTotal = array.reduce((a, b) => a + b.count, 0)\\n      const percentage = (count / countTotal) * 100\\n      const remainder = 100 - percentage\\n      return {\\n        ...item,\\n        percentage: percentage,\\n        remainder: remainder,\\n      }\\n    })\\n\\n- console.log(JSON.stringify(tagData, null, 2))\\n\\n  const colors = [\\\"#ff6090\\\", \\\"#3f51b5\\\", \\\"#00bcd4\\\", \\\"#8bc34a\\\", \\\"#ffc107\\\"]\\n\\n  return (\\n+    <div\\n+      style={{\\n+        margin: \\\"0 auto\\\",\\n+        width: 300,\\n+      }}\\n+    >\\n     <div\\n      style={{\\n        position: 'relative',\\n-       width: 300\\n       }}\\n      >\\n        <svg width=\\\"100%\\\" height=\\\"100%\\\" viewBox=\\\"0 0 40 40\\\">\\n          {tagData.map((tag, index) => {\\n            const { percentage, remainder } = tag\\n\\n            return (\\n              <circle\\n                key={index}\\n                cx=\\\"20\\\"\\n                cy=\\\"20\\\"\\n                r=\\\"15.91549430918954\\\"\\n                strokeDasharray={`${percentage} ${remainder}`}\\n                strokeDashoffset={\\n                  100 -\\n                  tagData\\n                    .slice(0, index)\\n                    .reduce((a, b) => a + b.percentage, 0) +\\n                  25\\n                }\\n                strokeWidth=\\\"6\\\"\\n                fill=\\\"transparent\\\"\\n                stroke={colors[index]}\\n              />\\n            )\\n          })}\\n        </svg>\\n+       <div\\n+         style={{\\n+            position: \\\"absolute\\\",\\n+            transform: \\\"translate(-50%, -50%)\\\",\\n+            top: \\\"50%\\\",\\n+            left: \\\"50%\\\",\\n+            textAlign: \\\"center\\\",\\n+          }}\\n+        >\\n+          <div\\n+            style={{\\n+              fontSize: \\\"20px\\\",\\n+              fontWeight: \\\"bold\\\",\\n+              lineHeight: \\\"14px\\\",\\n+            }}\\n+          >\\n+            Top 5 tags\\n+          </div>\\n+          <a\\n+            href=\\\"https://paulie.dev\\\"\\n+            target=\\\"_blank\\\"\\n+            rel=\\\"noreferrer\\\"\\n+            style={{ color: \\\"#ff6090\\\" }}\\n+          >\\n+            paulie.dev\\n+          </a>\\n+        </div>\\n      </div>\\n+      <div>\\n+        {tagData.map((item, index) => {\\n+          const { tag, percentage } = item\\n+          return (\\n+            <div\\n+              key={index}\\n+              style={{\\n+                alignItems: \\\"center\\\",\\n+                display: \\\"grid\\\",\\n+                gridTemplateColumns: \\\"1fr auto\\\",\\n+              }}\\n+            >\\n+              <div\\n+                style={{\\n+                  alignItems: \\\"center\\\",\\n+                  display: \\\"grid\\\",\\n+                  gridGap: 8,\\n+                  gridTemplateColumns: \\\"12px auto\\\",\\n+                }}\\n+              >\\n+                <div\\n+                  style={{\\n+                    width: 12,\\n+                    height: 12,\\n+                    borderRadius: \\\"100%\\\",\\n+                    backgroundColor: colors[index],\\n+                  }}\\n+                />\\n+                <div>{tag}</div>\\n+              </div>\\n+              <div>{`${Math.abs(percentage).toFixed(2)}%`}</div>\\n+            </div>\\n+          )\\n+        })}\\n      </div>\\n+    </div>\\n  )\\n}\\n\")), mdx(Divider, {\n    mdxType: \"Divider\"\n  }), mdx(\"h2\", null, mdx(\"a\", _extends({\n    parentName: \"h2\"\n  }, {\n    \"href\": \"#the-result\"\n  }), \"The Result\")), mdx(\"p\", null, \"Finally, here's the result \\uD83E\\uDD9C\"), mdx(MrDoughnut, {\n    mdxType: \"MrDoughnut\"\n  }));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"Charting libraries are great don't get me wrong but sometimes... you just need a bloody doughnut! 🍩 This post is largely based on this…","timeToRead":3,"wordCount":{"words":872},"slug":"2021/01/react-svg-doughnut-chart","frontmatter":{"title":"Create an Svg Doughnut Chart from scratch for your Gatsby blog","tags":["JavaScript","React","SVG","Gatsby","CSS"],"date":"2021-01-11T00:00:00.000Z","dateModified":null,"author":"Paul Scanlon","status":null,"isPrivate":null,"url":null,"misc":null,"pinned":null,"featuredImage":null,"embeddedImages":null},"featuredImageUrl":{"url":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/2wBDAQoLCw4NDhwQEBw7KCIoOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozv/wgARCAALABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAEDBv/EABYBAQEBAAAAAAAAAAAAAAAAAAABAv/aAAwDAQACEAMQAAAB5y4toE//xAAZEAACAwEAAAAAAAAAAAAAAAABEAIREgP/2gAIAQEAAQUC551IB3a//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAGBAAAgMAAAAAAAAAAAAAAAAAACAhIjH/2gAIAQEABj8CuRq//8QAGxAAAgIDAQAAAAAAAAAAAAAAAREAQRAhMXH/2gAIAQEAAT8h8ZFPjpzX0FlzFQkjOP/aAAwDAQACAAMAAAAQO9//xAAWEQADAAAAAAAAAAAAAAAAAAABEBH/2gAIAQMBAT8QpX//xAAVEQEBAAAAAAAAAAAAAAAAAAAQIf/aAAgBAgEBPxCH/8QAHBABAQABBQEAAAAAAAAAAAAAEQEAECExQVFh/9oACAEBAAE/EEERypA9G4+YfbiU/B75+caXEJVIR0//2Q=="},"images":{"fallback":{"src":"/static/fd56950268dc0c0f2a867f217495207a/ccd19/react-svg-doughnut-chart_u7wza7.jpg","srcSet":"/static/fd56950268dc0c0f2a867f217495207a/5de87/react-svg-doughnut-chart_u7wza7.jpg 750w,\n/static/fd56950268dc0c0f2a867f217495207a/ccd19/react-svg-doughnut-chart_u7wza7.jpg 1024w","sizes":"100vw"},"sources":[{"srcSet":"/static/fd56950268dc0c0f2a867f217495207a/5846e/react-svg-doughnut-chart_u7wza7.avif 750w,\n/static/fd56950268dc0c0f2a867f217495207a/47b7d/react-svg-doughnut-chart_u7wza7.avif 1024w","type":"image/avif","sizes":"100vw"},{"srcSet":"/static/fd56950268dc0c0f2a867f217495207a/d02c5/react-svg-doughnut-chart_u7wza7.webp 750w,\n/static/fd56950268dc0c0f2a867f217495207a/d819f/react-svg-doughnut-chart_u7wza7.webp 1024w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5625}}}},"embeddedImageUrls":null,"fields":{"slug":"/posts/2021/01/react-svg-doughnut-chart/","owner":"source","parent":"posts"}}},"pageContext":{"id":"25e64de7-709f-51d2-82ae-2d5d3bb66458","prev":{"frontmatter":{"title":"Understanding Theme UI: 1 - Jsx Pragma","status":null},"fields":{"slug":"/posts/2021/01/theme-ui-alpha-1/"}},"next":{"frontmatter":{"title":"Use Netlify Functions and the GitHub REST API to add Data Visualization to your Gatsby blog","status":null},"fields":{"slug":"/posts/2021/01/gatsby-netliyf-github-rest/"}},"parent":"posts"}},"staticQueryHashes":["1095393795","1469902088","2504239491","3642847879","571831435"]}